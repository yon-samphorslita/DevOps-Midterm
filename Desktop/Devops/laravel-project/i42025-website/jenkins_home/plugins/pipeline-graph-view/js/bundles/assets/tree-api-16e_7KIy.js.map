{"version":3,"file":"tree-api-16e_7KIy.js","sources":["../../../../frontend/pipeline-graph-view/pipeline-graph/main/support/startPollingPipelineStatus.ts","../../../../frontend/common/utils/run-estimator.ts","../../../../frontend/common/utils/stage-merge.ts","../../../../frontend/common/tree-api.ts"],"sourcesContent":["import {\n  getRunStatusFromPath,\n  RunStatus,\n} from \"../../../../common/RestClient.tsx\";\n/**\n * Starts polling the server to retrieve pipeline status.\n * Will only stop once the run is finished.\n */\nexport default async function startPollingPipelineStatus(\n  onFetchSuccess: (data: RunStatus) => void,\n  onFetchError: (err: Error) => void,\n  onPipelineComplete: () => void,\n  path: string,\n  interval = 3000,\n) {\n  let isComplete = false;\n\n  async function fetchPipelineData() {\n    try {\n      const result = await getRunStatusFromPath(path)!;\n      onFetchSuccess({ stages: result!.stages, complete: result!.complete });\n      isComplete = result!.complete;\n    } catch (err) {\n      // TODO: implement exponential backoff of the timeout interval\n      onFetchError(err);\n    } finally {\n      if (isComplete) {\n        onPipelineComplete();\n      } else {\n        setTimeout(() => fetchPipelineData(), interval);\n      }\n    }\n  }\n  fetchPipelineData();\n}\n","import {\n  Result,\n  StageInfo,\n} from \"../../pipeline-graph-view/pipeline-graph/main/index.ts\";\n\nexport default class RunEstimator {\n  private stagesLookup: Map<String, StageInfo>;\n\n  constructor(stages: StageInfo[]) {\n    this.stagesLookup = new Map(stages.map((stage) => [stage.name, stage]));\n  }\n\n  estimateCompletion(stage: StageInfo): number {\n    switch (stage.state) {\n      // BlueRunResult (implies BlueRunState == FINISHED)\n      case Result.success:\n      case Result.unstable:\n      case Result.failure:\n      case Result.unknown:\n      case Result.aborted:\n      // BlueRunState\n      case Result.skipped:\n      case Result.not_built: // not sure???\n        return 100;\n      case Result.running:\n      case Result.paused:\n        const previous = this.stagesLookup.get(stage.name);\n        if (previous === undefined) {\n          return 0; // No previous run, so no estimate\n        }\n        const previousTiming = previous.totalDurationMillis;\n        const currentTiming = stage.totalDurationMillis;\n        if (previousTiming <= currentTiming) {\n          return 99; // Assume 99% complete if the previous run was longer than the current run\n        }\n        return (currentTiming / previousTiming) * 100;\n      default:\n        return 0;\n    }\n  }\n}\n","import { StageInfo } from \"../../pipeline-graph-view/pipeline-graph/main/index.ts\";\nimport RunEstimator from \"./run-estimator.ts\";\n\nexport const mergeStageInfos = (\n  skeletons: StageInfo[],\n  incoming: StageInfo[],\n): StageInfo[] => {\n  const marked = markSkeleton(skeletons);\n  const estimator = new RunEstimator(marked);\n  const merged = incoming.map((incomingItem) => {\n    const match = marked.find((s) => s.name === incomingItem.name);\n    return {\n      ...(match ?? {}),\n      ...incomingItem,\n      skeleton: false,\n      completePercent: estimator.estimateCompletion(incomingItem),\n      children: mergeStageInfos(\n        match?.children ?? [],\n        incomingItem.children ?? [],\n      ),\n    };\n  });\n\n  if (merged.length === 0) {\n    return marked;\n  }\n\n  const nameToIndex = new Map<string, number>();\n  marked.forEach((s, idx) => nameToIndex.set(s.name, idx));\n\n  const hasUnknown = incoming.some((item) => !nameToIndex.has(item.name));\n  if (hasUnknown) {\n    return merged;\n  }\n\n  const lastRanIndex = incoming.reduce((maxIdx, item) => {\n    const idx = nameToIndex.get(item.name) ?? -1;\n    return idx > maxIdx ? idx : maxIdx;\n  }, -1);\n\n  const futureSkeletons = marked.filter((s) => {\n    const idx = nameToIndex.get(s.name) ?? Infinity;\n    return idx > lastRanIndex && !incoming.some((i) => i.name === s.name);\n  });\n\n  return [...merged, ...futureSkeletons];\n};\n\nconst markSkeleton = (stages: StageInfo[]): StageInfo[] =>\n  stages.map((s) => ({\n    ...s,\n    skeleton: true,\n    completePercent: 0,\n    children: markSkeleton(s.children ?? []),\n  }));\n","import { useEffect, useState } from \"react\";\nimport { getRunStatusFromPath, RunStatus } from \"./RestClient.tsx\";\nimport startPollingPipelineStatus from \"../pipeline-graph-view/pipeline-graph/main/support/startPollingPipelineStatus.ts\";\nimport { mergeStageInfos } from \"./utils/stage-merge.ts\";\n\nconst onPipelineComplete = () => undefined;\n\nconst onPollingError = (err: Error) =>\n  console.log(\"There was an error when polling the pipeline status\", err);\n\n/**\n * Polls a run, stopping once the run has completed\n * Optionally retrieves data from the prior run and overlays the new run on top\n */\nexport default function useRunPoller({\n  currentRunPath,\n  previousRunPath,\n}: RunPollerProps) {\n  const [run, setRun] = useState<RunStatus>();\n\n  useEffect(() => {\n    let onPipelineDataReceived: (data: RunStatus) => void;\n    if (previousRunPath) {\n      let previousRun: RunStatus | null = null;\n      onPipelineDataReceived = async (current: RunStatus) => {\n        if (current.complete) {\n          setRun(current);\n        } else {\n          if (previousRun == null) {\n            // only set the previous run if it is not yet set\n            previousRun = await getRunStatusFromPath(previousRunPath);\n          }\n          // error getting previous run\n          if (previousRun == null) {\n            setRun(current);\n          } else {\n            setRun({\n              stages: mergeStageInfos(previousRun!.stages, current.stages),\n              complete: false,\n            });\n          }\n        }\n      };\n    } else {\n      onPipelineDataReceived = (data: RunStatus) => setRun(data);\n    }\n    startPollingPipelineStatus(\n      onPipelineDataReceived,\n      onPollingError,\n      onPipelineComplete,\n      currentRunPath,\n    );\n  }, []);\n\n  return {\n    run,\n  };\n}\n\ninterface RunPollerProps {\n  currentRunPath: string;\n  previousRunPath?: string;\n}\n"],"names":["startPollingPipelineStatus","onFetchSuccess","onFetchError","onPipelineComplete","path","interval","isComplete","fetchPipelineData","result","getRunStatusFromPath","err","RunEstimator","stages","__publicField","stage","Result","previous","previousTiming","currentTiming","mergeStageInfos","skeletons","incoming","marked","markSkeleton","estimator","merged","incomingItem","match","s","nameToIndex","idx","item","lastRanIndex","maxIdx","futureSkeletons","i","onPollingError","useRunPoller","currentRunPath","previousRunPath","run","setRun","useState","useEffect","onPipelineDataReceived","previousRun","current","data"],"mappings":"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"}