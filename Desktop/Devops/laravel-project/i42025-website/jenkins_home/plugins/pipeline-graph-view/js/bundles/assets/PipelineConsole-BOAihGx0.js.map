{"version":3,"mappings":";mLAGA,SAAwBA,OACtB,WAAoCC,SAAS,GAAK,CAC5C,IAA0B,GAAIA,UAAS,UAC1BC,MAAuB,IAAI,EAExCC,OACJC,CAAc,EAAI,EAClBC,GAAE,iBAGEC,MAAqBF,SAEHC,SAEd,WAAa,WACLE,CAAA,OAAK,EAAI,IAAK,MAAK,cAIrCC,mBAAU,KACD,2BAAiB,WAA2B,CAC5C,8BAAiB,QACjB,QACE,uBAAoB,uBACpB,0BAAoB,SAK7BC,MAAA,CAAC,OACC,UAAU,4BACV,OAAS,qBAAqB,EAAGC,CAAU,QAAS,MAEpD,MAACD,OAAA,OAAI,UAAU,qCACZ,EAAAE,UAAM,CAAS,KAEhB,IAAC,OACC,MACA,YAAaR,OACb,OAAU,0BACZ,CACF,KAEC,UAAK,WAAM,WAAY,MCrCvB,cAA6B,OACP,MCGtB,QAAwBQ,CAAuB,CAC9C,OAAE,IAAI,EAAIC,GACd,kBAAsB,cACtB,gBAAiBD,MAAM,aACxB,CAEK,CAACE,OAA2BZ,UAAS,CAAE,EACvC,KAAgC,CAAIA,aAAqB,EACzD,CAACa,MAAmBb,UAAqB,EAAE,MACf,IAAI,aAChC,MAECc,EAAqBC,CAAsB,IAAIf,WAAc,IAEnDC,EAAmB,SAAE,EAEhCe,MAA0B,UAC9B,QAAuBC,IAAsBC,EAAsB,CACjE,OAAiBC,CAAY,KAAU,GAAK,MAC1C,CAAO,CAAC,KACR,WACA,aACA,MACF,EACA,OAAe,QAAY,GAAK,CAACF,MAAa,IAC9C,QAAiB,MAAMG,CAAqBC,EAAQH,IACpD,GAAKI,EAAU,WAET,IAAcA,EAAS,MAAK,MAAO,OAAM;AAAA,MAAU,CAErDC,EAAW,SAAU,EAAKA,EAAW,SAAWL,OACvC,KAAS,OAAc,GAAO,QAEzCK,CAAW,MAAQC,EACnBD,GAAW,SAAYD,EAAS,WAGlCC,EAAW,WAAmB,cAEL,SAAc,IAAIF,OAE7C,EACF,GAEMI,CAAiBC,EAAA,YACpBb,GAA+B,CACxB,QAAS,IAAI,oBAAgB,KAAS,WAAS,KAAO,gBACxD,IAAWc,EAAO,IAAI,eAAe,EACzC,GAAI,CAACC,EACI,kBAKT,GAAMC,EAAOhB,EAAM,KAAMiB,GAAMA,EAAE,KAAOF,EAAQ,CAC1CG,EAAqB,CAAC,KAE5B,IAAIF,QACc,UACP,KAAKA,GAAK,CAAE,IAGnBA,IAAK,CACL,KACA,YAAgB,CAAI,YAAY,GAAK,QAAuB,CAC9D,gBAMJ,CACA,CAACb,SAGmD,CACpD,GAAIF,OACF,iBAG6Be,CAASA,QAAS,EAAS,EAC1D,GAAI,CAAChB,QAAe,oBACX,WAEAgB,KAAQhB,MACX,CAAAmB,mBAAwB,SACHC,CAAA,aAAAA,CAAc,MAAM,eAC7C,MAAQD,gBACM,EACZ,KAAKE,EAAO,mBACA,EAEH,OAAAL,GACT,WAAY,IACZ,KAAKK,IAAO,YACPA,CAAO,UACN,CAAAC,UAGK,MAET,UACF,YAE4BH,CAAcG,IACvBF,IACjB,CACJ,CAEK,SACT,CAEA1B,aAAU,GAAM,SACA,CAAMM,IAKlB,MAJQA,cAG4B,EACtB,CACN,MAAAuB,GAAcC,CAAuBxB,CAAK,GAC5CuB,GACFE,QAAyB,GAAO,QAEhB,MACdC,EAAkBC,MAAU,CAAGA,EAAMJ,GAAY,CAAE,IACnDpB,CAAwBoB,EAAY,GAAI,SAE5C,CAGGK,GAAA,OAAAA,CAAK,UACaC,cACnB,iBACSC,CAAS,eAET,kBAA0B,IAAM,KAAK,UAAUA,CAAI,EAE1D,GAAI7B,EAAqB,CACjB,YAA0C,CAC5CsB,IACFE,EAAaF,EAAY,YAET,SACdG,EAAkBC,UAAmBJ,CAAY,GAAG,IAElDA,EAAY,GACZ,GACA,EAAIQ,QAMRC,CACFC,EAASH,CAAI,EACbI,EAAS,QAAUJ,EAEvB,EACA,eAAe,MAAOF,EAAA,MAAAA,EAAK,WAC3B,WAEJ,CACD,GACA,SAAC,YAAK,GAAM,CAAC,MAEhB,EAAMO,EAAoBtB,EAAA,YACvBuB,GAAmB,CAIlB,GAHAlC,MAEI,CAACkC,KACDA,EAAWrC,MAAW,GAE1B,OAAMsC,CAAgBrC,EAAM,OAAQgB,MAAc,SAAYoB,CAAM,IACnDC,EAAcA,MAAc","names":["SplitView","useState","useRef","startDragging","setIsDragging","e","stopDragging","setPanelWidth","useEffect","jsxs","panelWidth","props","useRunPoller","openStage","steps","userManuallySetNode","setUserManuallySetNode","updateStepConsoleOffset","forceUpdate","startByte","stepBuffers","getConsoleTextOffset","stepId","response","stepBuffer","newLogLines","parseUrlParams","useCallback","params","selected","step","s","expanded","stepResult","selectedStep","Result","selectedStepResult","defaultStep","getDefaultSelectedStep","setOpenStage","setExpandedSteps","prev","run","startPollingPipeline","data","LOG_FETCH_SIZE","hasNewSteps","setSteps","stepsRef","handleStageSelect","nodeId","stepsForStage"],"ignoreList":[],"sources":["../../../../frontend/pipeline-console-view/pipeline-console/main/SplitView.tsx","../../../../frontend/pipeline-console-view/pipeline-console/main/PipelineConsoleModel.tsx","../../../../frontend/pipeline-console-view/pipeline-console/main/hooks/use-steps-poller.ts"],"sourcesContent":["import React, { useState, useRef, useEffect } from \"react\";\nimport \"./split-view.scss\";\n\nexport default function SplitView(props: SplitViewNewProps) {\n  const [isDragging, setIsDragging] = useState(false);\n  const [panelWidth, setPanelWidth] = useState(300);\n  const dividerRef = useRef<HTMLDivElement>(null);\n\n  const startDragging = (e: React.MouseEvent) => {\n    setIsDragging(true);\n    e.preventDefault();\n  };\n\n  const stopDragging = () => setIsDragging(false);\n\n  const handleDragging = (e: MouseEvent) => {\n    if (isDragging) {\n      const newWidth = e.clientX - 40;\n      setPanelWidth(Math.max(200, Math.min(newWidth, 500)));\n    }\n  };\n\n  useEffect(() => {\n    window.addEventListener(\"mousemove\", handleDragging);\n    window.addEventListener(\"mouseup\", stopDragging);\n    return () => {\n      window.removeEventListener(\"mousemove\", handleDragging);\n      window.removeEventListener(\"mouseup\", stopDragging);\n    };\n  });\n\n  return (\n    <div\n      className=\"pgv-split-view__container\"\n      style={{ gridTemplateColumns: `${panelWidth}px 1fr` }}\n    >\n      <div className=\"pgv-split-view__side-panel\">\n        {props.children[0]}\n\n        <div\n          ref={dividerRef}\n          onMouseDown={startDragging}\n          className=\"pgv-split-view__divider\"\n        />\n      </div>\n\n      <div>{props.children[1]}</div>\n    </div>\n  );\n}\n\ninterface SplitViewNewProps {\n  children: React.ReactNode[];\n}\n","// re-export Result so the relative path exists in one location.\nexport { Result } from \"../../../pipeline-graph-view/pipeline-graph/main/PipelineGraphModel.tsx\";\n\nexport type {\n  StageInfo,\n  StageType,\n} from \"../../../pipeline-graph-view/pipeline-graph/main/PipelineGraphModel.tsx\";\nexport * from \"../../../common/RestClient.tsx\";\n\nexport const LOG_FETCH_SIZE = 150 * 1024;\nexport const POLL_INTERVAL = 1000;\n","import { useCallback, useEffect, useRef, useState } from \"react\";\nimport {\n  getConsoleTextOffset,\n  getRunSteps,\n  LOG_FETCH_SIZE,\n  POLL_INTERVAL,\n  Result,\n  StageInfo,\n  StepInfo,\n  StepLogBufferInfo,\n} from \"../PipelineConsoleModel.tsx\";\nimport useRunPoller from \"../../../../common/tree-api.ts\";\n\nexport function useStepsPoller(props: RunPollerProps) {\n  const { run } = useRunPoller({\n    currentRunPath: props.currentRunPath,\n    previousRunPath: props.previousRunPath,\n  });\n\n  const [openStage, setOpenStage] = useState(\"\");\n  const [expandedSteps, setExpandedSteps] = useState<string[]>([]);\n  const [steps, setSteps] = useState<StepInfo[]>([]);\n  const [stepBuffers, setStepBuffers] = useState(\n    new Map<string, StepLogBufferInfo>(),\n  );\n  const [userManuallySetNode, setUserManuallySetNode] = useState(false);\n\n  const stepsRef = useRef<StepInfo[]>([]);\n\n  const updateStepConsoleOffset = useCallback(\n    async (stepId: string, forceUpdate: boolean, startByte: number) => {\n      let stepBuffer = stepBuffers.get(stepId) ?? {\n        lines: [],\n        startByte: 0 - LOG_FETCH_SIZE,\n        endByte: -1,\n        stepId,\n      };\n      if (stepBuffer.startByte > 0 && !forceUpdate) return;\n      const response = await getConsoleTextOffset(stepId, startByte);\n      if (!response) return;\n\n      const newLogLines = response.text.trim().split(\"\\n\") || [];\n\n      if (stepBuffer.endByte > 0 && stepBuffer.endByte <= startByte) {\n        stepBuffer.lines = [...stepBuffer.lines, ...newLogLines];\n      } else {\n        stepBuffer.lines = newLogLines;\n        stepBuffer.startByte = response.startByte;\n      }\n\n      stepBuffer.endByte = response.endByte;\n\n      setStepBuffers((prev) => new Map(prev).set(stepId, stepBuffer));\n    },\n    [],\n  );\n\n  const parseUrlParams = useCallback(\n    (steps: StepInfo[]): boolean => {\n      const params = new URLSearchParams(document.location.search.substring(1));\n      let selected = params.get(\"selected-node\");\n      if (!selected) {\n        return false;\n      }\n\n      setUserManuallySetNode(true);\n\n      const step = steps.find((s) => s.id === selected);\n      const expanded: string[] = [];\n\n      if (step) {\n        selected = step.stageId;\n        expanded.push(step.id);\n\n        updateStepConsoleOffset(\n          step.id,\n          false,\n          parseInt(params.get(\"start-byte\") || `${0 - LOG_FETCH_SIZE}`),\n        );\n      }\n\n      setOpenStage(selected);\n      setExpandedSteps(expanded);\n      return true;\n    },\n    [updateStepConsoleOffset],\n  );\n\n  const getDefaultSelectedStep = (steps: StepInfo[]) => {\n    if (userManuallySetNode) {\n      return;\n    }\n\n    let selectedStep = steps.find((step) => step !== undefined);\n    if (!steps || steps.length == 0 || !selectedStep) {\n      return null;\n    }\n    for (let step of steps) {\n      let stepResult = step.state.toLowerCase() as Result;\n      let selectedStepResult = selectedStep?.state.toLowerCase() as Result;\n      switch (stepResult) {\n        case Result.running:\n        case Result.queued:\n        case Result.paused:\n          // Return first running/queued/paused step.\n          return step;\n        case Result.unstable:\n        case Result.failure:\n        case Result.aborted:\n          if (selectedStepResult && stepResult < selectedStepResult) {\n            // Return first unstable/failed/aborted step which has a state worse than the selectedStep.\n            // E.g. if the first step state is failure we want to return that over a later unstable step.\n            return step;\n          }\n          continue;\n        default:\n          // Otherwise select the step with the worst result with the largest id - e.g. (last step if all successful).\n          if (selectedStepResult && stepResult <= selectedStepResult) {\n            selectedStep = step;\n          }\n      }\n    }\n    return selectedStep;\n  };\n\n  useEffect(() => {\n    getRunSteps().then((steps) => {\n      steps = steps || [];\n      setSteps(steps);\n\n      const usedUrl = parseUrlParams(steps);\n      if (!usedUrl) {\n        const defaultStep = getDefaultSelectedStep(steps);\n        if (defaultStep) {\n          setOpenStage(defaultStep.stageId);\n\n          if (defaultStep.stageId) {\n            setExpandedSteps((prev) => [...prev, defaultStep.id]);\n            updateStepConsoleOffset(defaultStep.id, false, 0 - LOG_FETCH_SIZE);\n          }\n        }\n      }\n\n      if (!run?.complete) {\n        startPollingPipeline({\n          getStateUpdateFn: getRunSteps,\n          onData: (data) => {\n            const hasNewSteps =\n              JSON.stringify(stepsRef.current) !== JSON.stringify(data);\n\n            if (userManuallySetNode) {\n              const defaultStep = getDefaultSelectedStep(steps);\n              if (defaultStep) {\n                setOpenStage(defaultStep.stageId);\n\n                if (defaultStep.stageId) {\n                  setExpandedSteps((prev) => [...prev, defaultStep.id]);\n                  updateStepConsoleOffset(\n                    defaultStep.id,\n                    false,\n                    0 - LOG_FETCH_SIZE,\n                  );\n                }\n              }\n            }\n\n            if (hasNewSteps) {\n              setSteps(data);\n              stepsRef.current = data;\n            }\n          },\n          checkComplete: () => !run?.complete,\n          interval: POLL_INTERVAL,\n        });\n      }\n    });\n  }, [run?.stages]);\n\n  const handleStageSelect = useCallback(\n    (nodeId: string) => {\n      setUserManuallySetNode(true);\n\n      if (!nodeId) return;\n      if (nodeId === openStage) return; // skip if already selected\n\n      const stepsForStage = steps.filter((step) => step.stageId === nodeId);\n      const lastStep = stepsForStage[stepsForStage.length - 1];\n      const newlyExpandedSteps = lastStep ? [lastStep.id] : [];\n\n      setOpenStage(nodeId);\n      setExpandedSteps((prev) => [...prev, ...newlyExpandedSteps]);\n\n      if (lastStep) {\n        updateStepConsoleOffset(lastStep.id, false, 0 - LOG_FETCH_SIZE);\n      }\n    },\n    [openStage, steps, updateStepConsoleOffset],\n  );\n\n  const handleStepToggle = (nodeId: string) => {\n    setUserManuallySetNode(true);\n    if (!expandedSteps.includes(nodeId)) {\n      setExpandedSteps((prev) => [...prev, nodeId]);\n      updateStepConsoleOffset(nodeId, false, 0 - LOG_FETCH_SIZE);\n    } else {\n      setExpandedSteps((prev) => prev.filter((id) => id !== nodeId));\n    }\n  };\n\n  const handleMoreConsoleClick = (nodeId: string, startByte: number) => {\n    updateStepConsoleOffset(nodeId, true, startByte);\n  };\n\n  const getStageSteps = (stageId: string) => {\n    return steps.filter((step) => step.stageId === stageId);\n  };\n\n  const getStageStepBuffers = (stageId: string) => {\n    const buffers = new Map<string, StepLogBufferInfo>();\n    steps.forEach((step) => {\n      if (step.stageId === stageId && stepBuffers.has(step.id)) {\n        buffers.set(step.id, stepBuffers.get(step.id)!);\n      }\n    });\n    return buffers;\n  };\n\n  const getOpenStage = (): StageInfo | null => {\n    const findStage = (stages: StageInfo[]): StageInfo | null => {\n      for (let stage of stages) {\n        if (String(stage.id) === openStage) return stage;\n        if (stage.children.length > 0) {\n          const result = findStage(stage.children);\n          if (result) return result;\n        }\n      }\n      return null;\n    };\n    return openStage ? findStage(run?.stages || []) : null;\n  };\n\n  return {\n    openStage: getOpenStage(),\n    openStageSteps: getStageSteps(openStage),\n    openStageStepBuffers: getStageStepBuffers(openStage),\n    expandedSteps,\n    stages: run?.stages || [],\n    handleStageSelect,\n    handleStepToggle,\n    handleMoreConsoleClick,\n  };\n}\n\n/**\n * Starts polling a function until a complete condition is met.\n */\nconst startPollingPipeline = ({\n  getStateUpdateFn,\n  onData,\n  checkComplete,\n  interval = 1000,\n}: {\n  getStateUpdateFn: () => Promise<StepInfo[] | null>;\n  onData: (data: StepInfo[]) => void;\n  checkComplete: (data: StepInfo[]) => boolean;\n  interval?: number;\n}): (() => void) => {\n  let polling = true;\n\n  const poll = async () => {\n    while (polling) {\n      const data = (await getStateUpdateFn()) || [];\n      onData(data);\n\n      if (checkComplete(data)) {\n        polling = false;\n        break;\n      }\n\n      await new Promise((resolve) => setTimeout(resolve, interval));\n    }\n  };\n\n  setTimeout(poll, interval);\n\n  return () => {\n    polling = false;\n  };\n};\n\ninterface RunPollerProps {\n  currentRunPath: string;\n  previousRunPath?: string;\n}\n"],"file":"assets/PipelineConsole-BOAihGx0.js"}